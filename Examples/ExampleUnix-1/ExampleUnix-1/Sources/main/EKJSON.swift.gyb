%{
commands = [('translate', 'Translate', 'EKVector3.init'),
			('rotate', 'Rotate', 'EKRotation.createRotation(fromArray:)'),
			('scale', 'Scale', 'EKVector3.init'),
			('changeColor', 'ChangeColor', 'EKColor.init(fromArray:)')]
}%
// LOCK: File generated by gyb, do not edit
public enum EKCommand: String {
% for (command, Command, transform) in commands:
    case ${command}
%end
	case changeName
	case remove
	case add

	static func applyCommand(fromJSON JSONObject: Any) {
		guard let rootDictionary = JSONObject as? [String: Any],
			let actionString = rootDictionary["action"] as? String,
			let command = EKCommand(rawValue: actionString),
			let parameters = rootDictionary["parameters"] as? [String: Any]
			else {
				return
		}

		switch command {
% for (command, Command, transform) in commands:
		case .${command}:
			apply${Command}(withParameters: parameters)
%end
		case .changeName:
			applyChangeName(withParameters: parameters)
		case .remove:
			applyRemove(withParameters: parameters)
		case .add:
			applyAdd(withParameters: parameters)
		}
	}

	//
% for (command, Command, transform) in commands:
	static func apply${Command}(withParameters parameters: [String: Any]) {
		guard let targets = getTargets(parameters),
			let object = getObject(parameters)
			else {
				return
		}

		let animationTargets = targets.map(${transform})

		EKAnimation${Command}(
			duration: 1.0,
			chainValues: animationTargets,
			object: object
			)?.start()
	}

%end
	static func applyChangeName(withParameters parameters: [String: Any]) {
		guard let newName = parameters["name"] as? String,
			let object = getObject(parameters)
			else {
				return
		}

		object.name = newName
	}

	static func applyRemove(withParameters parameters: [String: Any]) {
		guard let object = getObject(parameters)
			else {
				return
			}

			object.destroy()
	}

	@discardableResult
	static func applyAdd(withParameters parameters: [String: Any])
		-> EKGLObject?
	{
		guard let meshName = parameters["mesh"] as? String,
			let vertexComponent = EKGLVertexComponent.component(
				forGeometryNamed: meshName)
			else {
				return nil
			}
		let object = EKGLObject(vertexComponent: vertexComponent)

		if let position = parameters["position"] {
			let vector = EKVector3(fromValue: position)
			object.position = vector
		}
		if let scale = parameters["scale"] {
			let vector = EKVector3(fromValue: scale)
			object.scale = vector
		}
		if let rotation = parameters["rotation"] {
			let vector = EKRotation.createRotation(
				fromObject: rotation as AnyObject)
			object.rotation = vector
		}
		if let color = parameters["color"] {
			let vector = EKColor(fromValue: color)
			object.color = vector
		}
		if let name = parameters["name"] as? String {
			object.name = name
		}

		if let children = parameters["children"] as? [[String: Any]] {
			for child in children {
				let childObject = applyAdd(withParameters: child)
				if let childObject = childObject {
					object.addChild(childObject)
				}
			}
		}

		return object
	}

	//
	static func getTargets(_ parameters: [String: Any]) -> [[Double]]? {
		return parameters["targets"] as? [[Double]]
	}

	static func getObject(_ parameters: [String: Any]) -> EKGLObject? {
		guard let objectID = parameters["id"] as? Int else { return nil }
		return EKGLObject.object(withID: objectID)
	}
}

extension EKGLObject {
	public func exportToJSON() -> [String: Any] {
		var json = [String: Any]()
		if let vertexComponent = self.vertexComponent {
			json["mesh"] = vertexComponent.meshName
		}

		json["name"] = self.name

		json["color"] = self.color.toArray()

		json["position"] = self.position.toArray()
		json["scale"] = self.scale.toArray()
		json["rotation"] = self.rotation.toArray()

		if self.children.count > 0 {
			var childrenJSON = [[String: Any]]()

			for child in self.children {
				childrenJSON.append(child.exportToJSON())
			}

			json["children"] = childrenJSON
		}

		return json
	}
}
